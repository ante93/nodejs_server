'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _shelljs = require('shelljs');

var _shelljs2 = _interopRequireDefault(_shelljs);

var _inquirer = require('inquirer');

var _inquirer2 = _interopRequireDefault(_inquirer);

var _commonUtil = require('../../common/util');

var _parsers = require('../parsers');

var _commitizen = require('../../commitizen');

var _git = require('../../git');

var _git2 = require('./git');

var gitStrategy = _interopRequireWildcard(_git2);

// destructure for shorter apis
var parse = _parsers.gitCz.parse;
var getNearestNodeModulesDirectory = _commitizen.adapter.getNearestNodeModulesDirectory;
var getNearestProjectRootDirectory = _commitizen.adapter.getNearestProjectRootDirectory;
var getPrompter = _commitizen.adapter.getPrompter;
var isClean = _commitizen.staging.isClean;
exports['default'] = gitCz;

function gitCz(rawGitArgs, environment, adapterConfig) {

  // See if any override conditions exist.

  // In these very specific scenarios we may want to use a different
  // commit strategy than git-cz. For example, in the case of --amend
  var parsedCommitizenArgs = _parsers.commitizen.parse(rawGitArgs);

  if (parsedCommitizenArgs.a) {
    // console.log('override -a in place');
    (0, _git.addPath)(_shelljs2['default'], process.cwd());
  }

  if (parsedCommitizenArgs.amend) {
    // console.log('override --amend in place');
    gitStrategy['default'](rawGitArgs, environment);
    return;
  }

  // Now, if we've made it past overrides, proceed with the git-cz strategy
  var parsedGitCzArgs = parse(rawGitArgs);

  // TODO: This can be broken out into its own function.
  // Basically we're
  // 1. Walking up the tree to find a node_modules folder
  // 2. Resolving the project root based on the node_modules folder
  // 3. Resolving the adapter bath based on that project root
  var resolvedAdapterConfigPath = _path2['default'].join(getNearestProjectRootDirectory(), adapterConfig.path);

  var prompter = getPrompter(_path2['default'].resolve(process.cwd(), resolvedAdapterConfigPath));

  isClean(process.cwd(), function (stagingIsClean) {
    if (stagingIsClean) {
      console.error('Error: No files added to staging! Did you forget to run git add?');
    } else {

      // OH GOD IM SORRY FOR THIS SECTION
      var adapterPackageJson = (0, _commonUtil.getParsedPackageJsonFromPath)(resolvedAdapterConfigPath);
      var cliPackageJson = (0, _commonUtil.getParsedPackageJsonFromPath)(environment.cliPath);
      console.log('cz-cli@' + cliPackageJson.version + ', ' + adapterPackageJson.name + '@' + adapterPackageJson.version + '\n');
      (0, _commitizen.commit)(_shelljs2['default'], _inquirer2['default'], process.cwd(), prompter, { args: parsedGitCzArgs, disableAppendPaths: true, emitData: true, quiet: false }, function () {
        // console.log('commit happened');
      });
    }
  });
}
module.exports = exports['default'];